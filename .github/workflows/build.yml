name: Launcher Build
on:
  push:
    branches: [ master ]

jobs:
  create-release:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      - name: Get version
        run: echo "version=$(jq -r .version package.json)" >> $GITHUB_ENV
      
      - name: Check if tag exists
        id: check_tag
        run: |
          if git rev-parse "${{ env.version }}" >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "Tag ${{ env.version }} already exists, will use existing release"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "Tag ${{ env.version }} does not exist, will create new release"
          fi
      
      - name: Create Release
        if: steps.check_tag.outputs.exists == 'false'
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.version }}
          release_name: release ${{ env.version }}
          draft: false
          prerelease: ${{ contains(env.version, 'beta') || contains(env.version, 'alpha') }}
      
      - name: Get existing release ID
        if: steps.check_tag.outputs.exists == 'true'
        id: get_release
        uses: actions/github-script@v6
        with:
          script: |
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            const release = releases.find(r => r.tag_name === '${{ env.version }}');
            if (release) {
              core.setOutput('id', release.id.toString());
              core.setOutput('upload_url', release.upload_url);
            } else {
              // Si le tag existe mais pas la release, on cr√©e la release
              const { data: newRelease } = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: '${{ env.version }}',
                name: 'release ${{ env.version }}',
                draft: false,
                prerelease: ${{ contains(env.version, 'beta') || contains(env.version, 'alpha') }}
              });
              core.setOutput('id', newRelease.id.toString());
              core.setOutput('upload_url', newRelease.upload_url);
            }
      
      - name: Set release outputs for existing release
        if: steps.check_tag.outputs.exists == 'true'
        run: |
          echo "release_id=${{ steps.get_release.outputs.id }}" >> $GITHUB_ENV
          echo "upload_url=${{ steps.get_release.outputs.upload_url }}" >> $GITHUB_ENV

  build-launcher:
    needs: create-release
    runs-on: ${{ matrix.os }}

    strategy:
      matrix:
        os: [macos-14, ubuntu-latest, windows-latest]

    steps:
      - name: Check out Git repository
        uses: actions/checkout@v1

      - name: Get version
        run: echo "version=$(jq -r .version package.json)" >> $GITHUB_ENV

      - name: Set up Node
        uses: actions/setup-node@v3
        with:
          node-version: 18.x

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: 3.x

      - name: Install Dependencies
        run: npm ci
        shell: bash

      - name: Build
        env:
          GH_TOKEN: ${{ secrets.github_token }}
        run: npm run build
        shell: bash
      
      - name: List dist files
        run: |
          echo "Fichiers dans dist/:"
          ls -la dist/ || echo "Dossier dist/ non trouv√©"
        shell: bash
      
      - name: Get release ID (Windows only)
        if: matrix.os == 'windows-latest'
        id: get_release
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            // R√©cup√©rer la version depuis package.json
            const fs = require('fs');
            const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
            const version = packageJson.version;
            
            console.log(`Recherche de la release pour le tag: ${version}`);
            
            const { data: releases } = await github.rest.repos.listReleases({
              owner: context.repo.owner,
              repo: context.repo.repo,
            });
            
            console.log(`Nombre de releases trouv√©es: ${releases.length}`);
            
            const release = releases.find(r => r.tag_name === version || r.tag_name === `v${version}`);
            
            if (release) {
              core.setOutput('id', release.id.toString());
              core.setOutput('upload_url', release.upload_url);
              console.log(`‚úÖ Release trouv√©e: ID=${release.id}, Tag=${release.tag_name}`);
            } else {
              console.log('Releases disponibles:');
              releases.slice(0, 5).forEach(r => console.log(`  - ${r.tag_name} (ID: ${r.id})`));
              core.setFailed(`Release non trouv√©e pour le tag ${version} ou v${version}`);
            }
      
      - name: Upload Windows artifacts to release
        if: matrix.os == 'windows-latest' && steps.get_release.outputs.id != ''
        uses: actions/github-script@v6
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const releaseId = '${{ steps.get_release.outputs.id }}';
            
            if (!releaseId) {
              core.setFailed('Release ID non disponible');
              return;
            }
            
            const distDir = 'dist';
            const filesToUpload = [
              'EarthKingdoms-Launcher-win-x64.exe',
              'EarthKingdoms-Launcher-win-x64.exe.blockmap',
              'latest.yml'
            ];
            
            console.log(`Upload vers release ID: ${releaseId}`);
            
            for (const fileName of filesToUpload) {
              const filePath = path.join(distDir, fileName);
              if (fs.existsSync(filePath)) {
                const fileContent = fs.readFileSync(filePath);
                const fileSize = fs.statSync(filePath).size;
                
                console.log(`üì§ Upload de ${fileName} (${(fileSize / 1024 / 1024).toFixed(2)} MB)...`);
                
                try {
                  await github.rest.repos.uploadReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: parseInt(releaseId),
                    name: fileName,
                    data: fileContent,
                    headers: {
                      'content-type': fileName.endsWith('.exe') ? 'application/octet-stream' : 
                                     fileName.endsWith('.yml') ? 'text/yaml' : 
                                     'application/octet-stream',
                      'content-length': fileSize
                    }
                  });
                  
                  console.log(`‚úÖ ${fileName} upload√© avec succ√®s`);
                } catch (error) {
                  if (error.status === 422 && error.message.includes('already exists')) {
                    console.log(`‚ö†Ô∏è ${fileName} existe d√©j√†, remplacement...`);
                    // R√©cup√©rer les assets existants et supprimer l'ancien
                    const { data: assets } = await github.rest.repos.listReleaseAssets({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      release_id: parseInt(releaseId),
                    });
                    const existingAsset = assets.find(a => a.name === fileName);
                    if (existingAsset) {
                      await github.rest.repos.deleteReleaseAsset({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        asset_id: existingAsset.id,
                      });
                      // R√©essayer l'upload
                      await github.rest.repos.uploadReleaseAsset({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        release_id: parseInt(releaseId),
                        name: fileName,
                        data: fileContent,
                        headers: {
                          'content-type': fileName.endsWith('.exe') ? 'application/octet-stream' : 
                                         fileName.endsWith('.yml') ? 'text/yaml' : 
                                         'application/octet-stream',
                          'content-length': fileSize
                        }
                      });
                      console.log(`‚úÖ ${fileName} remplac√© avec succ√®s`);
                    }
                  } else {
                    throw error;
                  }
                }
              } else {
                console.log(`‚ö†Ô∏è Fichier non trouv√©: ${filePath}`);
              }
            }
